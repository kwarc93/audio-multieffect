// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.1
// LVGL version: 8.3.6
// Project name: gmfx

#include "ui.h"

#include "lcd_view.hpp"

#include <cassert>
#include <string>

//-----------------------------------------------------------------------------
/* private */

namespace
{

namespace events = mfx::lcd_view_events;

mfx::lcd_view *view;

void notify_effect_bypass_changed(lv_obj_t *obj, mfx::effect_id effect)
{
    bool bypassed = !lv_obj_has_state(obj, LV_STATE_CHECKED);
    const events::effect_bypass_changed evt {effect, bypassed};
    view->notify(evt);
}

void notify_tremolo_controls_changed(void)
{
    lv_obj_t *rate_knob = ui_arc_trem_rate;
    lv_obj_t *depth_knob = ui_arc_trem_depth;
    lv_obj_t *shape_sw = ui_sw_trem_shape;

    const mfx::tremolo_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(rate_knob)),
        static_cast<float>(lv_arc_get_value(depth_knob)) * 0.01f,
        lv_obj_has_state(shape_sw, LV_STATE_CHECKED) ?
        mfx::tremolo_attr::controls::shape_type::square :
        mfx::tremolo_attr::controls::shape_type::sine
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_echo_controls_changed(void)
{
    lv_obj_t *blur_knob = ui_arc_echo_blur;
    lv_obj_t *time_knob = ui_arc_echo_time;
    lv_obj_t *feedback_knob = ui_arc_echo_feedb;
    lv_obj_t *mode_sw = ui_sw_echo_mode;

    const mfx::echo_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(blur_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(time_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(feedback_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::echo_attr::controls::mode_type::delay :
        mfx::echo_attr::controls::mode_type::echo
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_chorus_controls_changed(void)
{
    lv_obj_t *mix_knob = ui_arc_chorus_mix;
    lv_obj_t *depth_knob = ui_arc_chorus_depth;
    lv_obj_t *rate_knob = ui_arc_chorus_rate;
    lv_obj_t *mode_sw = ui_sw_chorus_mode;

    const mfx::chorus_attr::controls ctrl
    {
        lv_arc_get_value(depth_knob) * 0.01f,
        lv_arc_get_value(rate_knob) * 0.01f,
        0, // Not used
        lv_arc_get_value(mix_knob) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::chorus_attr::controls::mode_type::deep :
        mfx::chorus_attr::controls::mode_type::white
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_reverb_controls_changed(void)
{
    lv_obj_t *bw_knob = ui_arc_reverb_bw;
    lv_obj_t *damp_knob = ui_arc_reverb_damp;
    lv_obj_t *decay_knob = ui_arc_reverb_decay;
    lv_obj_t *mode_sw = ui_sw_reverb_mode;

    const mfx::reverb_attr::controls ctrl
    {
        lv_arc_get_value(bw_knob) * 0.01f,
        lv_arc_get_value(damp_knob) * 0.01f,
        lv_arc_get_value(decay_knob) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::reverb_attr::controls::mode_type::mod :
        mfx::reverb_attr::controls::mode_type::plate
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_overdrive_controls_changed(void)
{
    lv_obj_t *mix_knob = ui_arc_od_mix;
    lv_obj_t *gain_knob = ui_arc_od_gain;
    lv_obj_t *tone_knob = ui_arc_od_tone;
    lv_obj_t *mode_sw = ui_sw_od_mode;

    const mfx::overdrive_attr::controls ctrl
    {
        1.0f - (static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f),
        static_cast<float>(lv_arc_get_value(gain_knob)),
        static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(mix_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::overdrive_attr::controls::mode_type::hard :
        mfx::overdrive_attr::controls::mode_type::soft
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_cabinet_sim_controls_changed(void)
{
    lv_obj_t *ir_list = ui_roller_cab_sim_ir;

    const mfx::cabinet_sim_attr::controls ctrl
    {
        static_cast<uint8_t>(lv_roller_get_selected(ir_list)),
        mfx::cabinet_sim_attr::controls::resolution::standart,
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_vocoder_controls_changed(void)
{
    lv_obj_t *clarity_knob = ui_arc_voc_clarity;
    lv_obj_t *bands_list = ui_roller_voc_bands;
    lv_obj_t *tone_knob = ui_arc_voc_tone;
    lv_obj_t *hold_btn = ui_btn_voc_hold;
    lv_obj_t *mode_sw = ui_sw_voc_mode;

    char band_str[4] {0};
    lv_roller_get_selected_str(bands_list, band_str, sizeof(band_str));
    auto bands = std::stoul(std::string(band_str));

    const mfx::vocoder_attr::controls ctrl
    {
        bands,
        lv_arc_get_value(clarity_knob) * 0.01f,
        lv_arc_get_value(tone_knob) * 0.01f,
        lv_obj_has_state(hold_btn, LV_STATE_CHECKED),
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::vocoder_attr::controls::mode_type::modern :
        mfx::vocoder_attr::controls::mode_type::vintage
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_phaser_controls_changed(void)
{
    lv_obj_t *rate_knob = ui_arc_pha_rate;

    const mfx::phaser_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(rate_knob) / 10.0f),
    };

    view->notify(events::effect_controls_changed {ctrl});
}

}

//-----------------------------------------------------------------------------
/* public */

void ui_set_user_data(void *user_data)
{
    assert(user_data != nullptr);
    view = static_cast<mfx::lcd_view*>(user_data);
}

void ui_user_init_actions(void)
{
    ui_fx_names_size = mfx::effect_name.size();
    ui_fx_names = mfx::effect_name.data();
}

void ui_splash_loaded(lv_event_t * e)
{
    view->notify(events::splash_loaded {});
}

void ui_effect_next(lv_event_t * e)
{
    view->notify(events::next_effect_screen_request {});
}

void ui_effect_prev(lv_event_t * e)
{
    view->notify(events::prev_effect_screen_request {});
}

void ui_settings_in_vol_changed(lv_event_t * e)
{
    lv_obj_t *main_in_slider = ui_sld_sett_main_in_vol;
    lv_obj_t *aux_in_slider = ui_sld_sett_aux_in_vol;

    uint8_t main_in_vol = lv_slider_get_value(main_in_slider);
    uint8_t aux_in_vol = lv_slider_get_value(aux_in_slider);

    const events::input_volume_changed evt {main_in_vol, aux_in_vol};
    view->notify(evt);
}

void ui_settings_out_vol_changed(lv_event_t * e)
{
    lv_obj_t *out_slider = ui_sld_sett_out_vol;

    uint8_t out_vol = lv_slider_get_value(out_slider);

    const events::output_volume_changed evt {out_vol};
    view->notify(evt);
}

void ui_settings_mute_audio(lv_event_t * e)
{
    const events::mute_changed evt {lv_obj_has_state(ui_sw_sett_mute_audio, LV_STATE_CHECKED)};
    view->notify(evt);
}

void ui_settings_route_mic_to_aux(lv_event_t * e)
{
    const events::route_mic_to_aux_changed evt {lv_obj_has_state(ui_sw_sett_route_mic_to_aux, LV_STATE_CHECKED)};
    view->notify(evt);
}

void ui_settings_add_effect(uint32_t id, uint32_t curr_id)
{
    const events::add_effect_request evt {static_cast<mfx::effect_id>(id), static_cast<mfx::effect_id>(curr_id)};
    view->notify(evt);
}

void ui_settings_remove_effect(uint32_t effect_id)
{
    const events::remove_effect_request evt {static_cast<mfx::effect_id>(effect_id)};
    view->notify(evt);
}

void ui_settings_move_effect(uint32_t effect_id, int32_t step)
{
    const events::move_effect_request evt {static_cast<mfx::effect_id>(effect_id), step};
    view->notify(evt);
}

void ui_tremolo_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::tremolo);
}

void ui_tremolo_rate_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_tremolo_depth_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_tremolo_shape_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_echo_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::echo);
}

void ui_echo_blur_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_feedb_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_time_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_mode_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_chorus_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::chorus);
}

void ui_chorus_mix_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_rate_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_depth_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_mode_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_reverb_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::reverb);
}

void ui_reverb_bw_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_reverb_damp_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_reverb_decay_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_reverb_mode_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_overdrive_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::overdrive);
}

void ui_overdrive_mix_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_low_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_gain_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_high_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_mode_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_cab_sim_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::cabinet_sim);
}

void ui_cab_sim_ir_changed(lv_event_t * e)
{
    notify_cabinet_sim_controls_changed();
}

void ui_vocoder_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::vocoder);
}

void ui_vocoder_clarity_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_tone_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_bands_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_mode_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_hold_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_phaser_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::phaser);
}

void ui_phaser_rate_changed(lv_event_t * e)
{
    notify_phaser_controls_changed();
}


