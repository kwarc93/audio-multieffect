// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.1
// LVGL version: 8.3.6
// Project name: gmfx

#include "ui.h"

/* FIXME: This is temporary 'glue' between view and model */
#include "app/model/effect_processor.hpp"

namespace
{

void ui_effect_bypass_changed(lv_obj_t *btn, mfx::effect_id effect)
{
    bool bypassed = !lv_obj_has_state(btn, LV_STATE_CHECKED);
    mfx::effect_processor::event evt {mfx::effect_processor::bypass_evt_t {effect, bypassed}};
    mfx::effect_processor::instance->send(evt);
}

void ui_tremolo_controls_changed(void)
{
    lv_obj_t *rate_knob = ui_arc_trem_rate;
    lv_obj_t *depth_knob = ui_arc_trem_depth;
    lv_obj_t *shape_sw = ui_sw_tremolo_shape;

    const mfx::tremolo::controls controls
    {
        static_cast<float>(lv_arc_get_value(rate_knob)),
        static_cast<float>(lv_arc_get_value(depth_knob)) * 0.01f,
        lv_obj_has_state(shape_sw, LV_STATE_CHECKED) ?
        mfx::tremolo::shape_type::sine : mfx::tremolo::shape_type::triangle
    };

    mfx::effect_processor::event evt {mfx::effect_processor::effect_controls_evt_t {controls}};
    mfx::effect_processor::instance->send(evt);
}

void ui_echo_controls_changed(void)
{
    lv_obj_t *blend_knob = ui_arc_echo_blend;
    lv_obj_t *time_knob = ui_arc_echo_time;
    lv_obj_t *feedback_knob = ui_arc_echo_feedb;
    lv_obj_t *mode_sw = ui_sw_echo_mode;

    const mfx::echo::controls controls
    {
        static_cast<float>(lv_arc_get_value(blend_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(time_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(feedback_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::echo::mode_type::delay : mfx::echo::mode_type::echo
    };

    mfx::effect_processor::event evt {mfx::effect_processor::effect_controls_evt_t {controls}};
    mfx::effect_processor::instance->send(evt);
}

void ui_overdrive_controls_changed(void)
{
    lv_obj_t *mix_knob = ui_arc_od_mix;
    lv_obj_t *gain_knob = ui_arc_od_gain;
    lv_obj_t *tone_knob = ui_arc_od_tone;
    lv_obj_t *mode_sw = ui_sw_od_mode;

    const mfx::overdrive::controls controls
    {
        1.0f - (static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f),
        static_cast<float>(lv_arc_get_value(gain_knob)),
        static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(mix_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::overdrive::mode_type::hard : mfx::overdrive::mode_type::soft
    };

    mfx::effect_processor::event evt {mfx::effect_processor::effect_controls_evt_t {controls}};
    mfx::effect_processor::instance->send(evt);
}

}

void ui_settings_in_vol_changed(lv_event_t * e)
{
    lv_obj_t *in_slider = ui_sld_in_vol;
    lv_obj_t *out_slider = ui_sld_out_vol;

    uint8_t in_vol = lv_slider_get_value(in_slider);
    uint8_t out_vol = lv_slider_get_value(out_slider);

    mfx::effect_processor::event evt {mfx::effect_processor::volume_evt_t {in_vol, out_vol}};
    mfx::effect_processor::instance->send(evt);
}

void ui_settings_out_vol_changed(lv_event_t * e)
{
    lv_obj_t *in_slider = ui_sld_in_vol;
    lv_obj_t *out_slider = ui_sld_out_vol;

    uint8_t in_vol = lv_slider_get_value(in_slider);
    uint8_t out_vol = lv_slider_get_value(out_slider);

    mfx::effect_processor::event evt {mfx::effect_processor::volume_evt_t {in_vol, out_vol}};
    mfx::effect_processor::instance->send(evt);
}

void ui_cab_sim_bypass(lv_event_t * e)
{
    ui_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::cabinet_sim);
}

void ui_tremolo_bypass(lv_event_t * e)
{
    ui_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::tremolo);
}

void ui_tremolo_rate_changed(lv_event_t * e)
{
    ui_tremolo_controls_changed();
}

void ui_tremolo_depth_changed(lv_event_t * e)
{
    ui_tremolo_controls_changed();
}

void ui_tremolo_shape_changed(lv_event_t * e)
{
    ui_tremolo_controls_changed();
}

void ui_echo_bypass(lv_event_t * e)
{
    ui_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::echo);
}

void ui_echo_blend_changed(lv_event_t * e)
{
    ui_echo_controls_changed();
}

void ui_echo_feedb_changed(lv_event_t * e)
{
    ui_echo_controls_changed();
}

void ui_echo_time_changed(lv_event_t * e)
{
    ui_echo_controls_changed();
}

void ui_echo_mode_changed(lv_event_t * e)
{
    ui_echo_controls_changed();
}

void ui_overdrive_bypass(lv_event_t * e)
{
    ui_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::overdrive);
}

void ui_overdrive_low_changed(lv_event_t * e)
{
    ui_overdrive_controls_changed();
}

void ui_overdrive_gain_changed(lv_event_t * e)
{
    ui_overdrive_controls_changed();
}

void ui_overdrive_high_changed(lv_event_t * e)
{
    ui_overdrive_controls_changed();
}

void ui_overdrive_mode_changed(lv_event_t * e)
{
    ui_overdrive_controls_changed();
}


