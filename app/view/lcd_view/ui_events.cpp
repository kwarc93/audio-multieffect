// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.1
// LVGL version: 8.3.6
// Project name: gmfx

#include "ui.h"

#include "lcd_view.hpp"

#include <cassert>
#include <string>

//-----------------------------------------------------------------------------
/* private */

namespace
{

namespace events = mfx::lcd_view_events;

mfx::lcd_view *view;

void notify_effect_bypass_changed(lv_obj_t *obj, mfx::effect_id effect)
{
    bool bypassed = !lv_obj_has_state(obj, LV_STATE_CHECKED);
    const events::effect_bypass_changed evt {effect, bypassed};
    view->notify(evt);
}

void notify_tuner_controls_changed(void)
{
    lv_obj_t *mute_btn = ui_btn_tuner_mute;

    const mfx::tuner_attr::controls ctrl
    {
        lv_obj_has_state(mute_btn, LV_STATE_CHECKED),
        mfx::tuner_attr::default_ctrl.a4_tuning // Changing tuning frequency is not supported yet
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_tremolo_controls_changed(void)
{
    lv_obj_t *rate_knob = ui_arc_trem_rate;
    lv_obj_t *depth_knob = ui_arc_trem_depth;
    lv_obj_t *shape_sw = ui_sw_trem_shape;

    const mfx::tremolo_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(rate_knob)),
        static_cast<float>(lv_arc_get_value(depth_knob)) * 0.01f,
        lv_obj_has_state(shape_sw, LV_STATE_CHECKED) ?
        mfx::tremolo_attr::controls::shape_type::square :
        mfx::tremolo_attr::controls::shape_type::sine
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_echo_controls_changed(void)
{
    lv_obj_t *blur_knob = ui_arc_echo_blur;
    lv_obj_t *time_knob = ui_arc_echo_time;
    lv_obj_t *feedback_knob = ui_arc_echo_feedb;
    lv_obj_t *mode_sw = ui_sw_echo_mode;

    const mfx::echo_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(blur_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(time_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(feedback_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::echo_attr::controls::mode_type::delay :
        mfx::echo_attr::controls::mode_type::echo
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_chorus_controls_changed(void)
{
    lv_obj_t *mix_knob = ui_arc_chorus_mix;
    lv_obj_t *depth_knob = ui_arc_chorus_depth;
    lv_obj_t *rate_knob = ui_arc_chorus_rate;
    lv_obj_t *mode_sw = ui_sw_chorus_mode;

    const mfx::chorus_attr::controls ctrl
    {
        lv_arc_get_value(depth_knob) * 0.01f,
        lv_arc_get_value(rate_knob) * 0.01f,
        0, // Not used
        lv_arc_get_value(mix_knob) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::chorus_attr::controls::mode_type::deep :
        mfx::chorus_attr::controls::mode_type::white
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_reverb_controls_changed(void)
{
    lv_obj_t *bw_knob = ui_arc_reverb_bw;
    lv_obj_t *damp_knob = ui_arc_reverb_damp;
    lv_obj_t *decay_knob = ui_arc_reverb_decay;
    lv_obj_t *mode_sw = ui_sw_reverb_mode;

    const mfx::reverb_attr::controls ctrl
    {
        lv_arc_get_value(bw_knob) * 0.01f,
        lv_arc_get_value(damp_knob) * 0.01f,
        lv_arc_get_value(decay_knob) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::reverb_attr::controls::mode_type::mod :
        mfx::reverb_attr::controls::mode_type::plate
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_overdrive_controls_changed(void)
{
    lv_obj_t *mix_knob = ui_arc_od_mix;
    lv_obj_t *gain_knob = ui_arc_od_gain;
    lv_obj_t *tone_knob = ui_arc_od_tone;
    lv_obj_t *mode_sw = ui_sw_od_mode;

    const mfx::overdrive_attr::controls ctrl
    {
        1.0f - (static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f),
        static_cast<float>(lv_arc_get_value(gain_knob)),
        static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(mix_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::overdrive_attr::controls::mode_type::hard :
        mfx::overdrive_attr::controls::mode_type::soft
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_cabinet_sim_controls_changed(void)
{
    lv_obj_t *ir_list = ui_roller_cab_sim_ir;

    const mfx::cabinet_sim_attr::controls ctrl
    {
        static_cast<uint8_t>(lv_roller_get_selected(ir_list)),
        mfx::cabinet_sim_attr::controls::resolution::standart,
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_vocoder_controls_changed(void)
{
    lv_obj_t *clarity_knob = ui_arc_voc_clarity;
    lv_obj_t *bands_list = ui_roller_voc_bands;
    lv_obj_t *tone_knob = ui_arc_voc_tone;
    lv_obj_t *hold_btn = ui_btn_voc_hold;
    lv_obj_t *mode_sw = ui_sw_voc_mode;

    char band_str[4] {0};
    lv_roller_get_selected_str(bands_list, band_str, sizeof(band_str));
    auto bands = std::stoul(std::string(band_str));

    const mfx::vocoder_attr::controls ctrl
    {
        bands,
        lv_arc_get_value(clarity_knob) * 0.01f,
        lv_arc_get_value(tone_knob) * 0.01f,
        lv_obj_has_state(hold_btn, LV_STATE_CHECKED),
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::vocoder_attr::controls::mode_type::modern :
        mfx::vocoder_attr::controls::mode_type::vintage
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_phaser_controls_changed(void)
{
    lv_obj_t *rate_knob = ui_arc_pha_rate;
    lv_obj_t *depth_knob = ui_arc_pha_depth;
    lv_obj_t *contour_sw = ui_sw_pha_contour;

    const mfx::phaser_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(rate_knob) / 100.0f),
        static_cast<float>(lv_arc_get_value(depth_knob) / 100.0f),
        lv_obj_has_state(contour_sw, LV_STATE_CHECKED) ?
        mfx::phaser_attr::controls::contour_mode::on :
        mfx::phaser_attr::controls::contour_mode::off
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_amp_sim_controls_changed(void)
{
    lv_obj_t *input_knob = ui_arc_amp_sim_input;
    lv_obj_t *drive_knob = ui_arc_amp_sim_drive;
    lv_obj_t *compression_knob = ui_arc_amp_sim_compr;
    lv_obj_t *bass_knob = ui_arc_amp_sim_bass;
    lv_obj_t *mids_knob = ui_arc_amp_sim_mids;
    lv_obj_t *treb_knob = ui_arc_amp_sim_treb;
    lv_obj_t *mode_sw = ui_sw_amp_sim_mode;

    const mfx::amp_sim_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(input_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(drive_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(compression_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(bass_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(mids_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(treb_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::amp_sim_attr::controls::mode_type::higain :
        mfx::amp_sim_attr::controls::mode_type::logain
    };

    view->notify(events::effect_controls_changed {ctrl});
}

}

//-----------------------------------------------------------------------------
/* public */

void ui_set_user_data(void *user_data)
{
    assert(user_data != nullptr);
    view = static_cast<mfx::lcd_view*>(user_data);
}

void ui_init_user_actions(void)
{
    ui_fx_names_size = mfx::effect_name.size();
    ui_fx_names = mfx::effect_name.data();
}

void ui_splash_loaded(lv_event_t * e)
{
    view->notify(events::splash_loaded {});
}

void ui_effect_next(lv_event_t * e)
{
    view->notify(events::next_effect_screen_request {});
}

void ui_effect_prev(lv_event_t * e)
{
    view->notify(events::prev_effect_screen_request {});
}

void ui_settings_dark_mode_changed(lv_event_t * e)
{
    bool dark_mode = lv_obj_has_state(ui_sw_sett_dark_mode, LV_STATE_CHECKED);

    const events::theme_changed evt {dark_mode};
    view->notify(evt);
}

void ui_settings_display_brightess_changed(lv_event_t * e)
{
    uint8_t brightness = lv_slider_get_value(ui_sld_sett_displ_bright);

    const events::lcd_brightness_changed evt {brightness};
    view->notify(evt);
}

void ui_settings_in_vol_changed(lv_event_t * e)
{
    lv_obj_t *main_in_slider = ui_sld_sett_main_in_vol;
    lv_obj_t *aux_in_slider = ui_sld_sett_aux_in_vol;

    uint8_t main_in_vol = lv_slider_get_value(main_in_slider);
    uint8_t aux_in_vol = lv_slider_get_value(aux_in_slider);

    const events::input_volume_changed evt {main_in_vol, aux_in_vol};
    view->notify(evt);
}

void ui_settings_out_vol_changed(lv_event_t * e)
{
    lv_obj_t *out_slider = ui_sld_sett_out_vol;

    uint8_t out_vol = lv_slider_get_value(out_slider);

    const events::output_volume_changed evt {out_vol};
    view->notify(evt);
}

void ui_settings_mute_audio(lv_event_t * e)
{
    const events::mute_changed evt {lv_obj_has_state(ui_sw_sett_mute_audio, LV_STATE_CHECKED)};
    view->notify(evt);
}

void ui_settings_route_mic_to_aux(lv_event_t * e)
{
    const events::route_mic_to_aux_changed evt {lv_obj_has_state(ui_sw_sett_route_mic_to_aux, LV_STATE_CHECKED)};
    view->notify(evt);
}

void ui_settings_usb_if_toggle(lv_event_t * e)
{
    const bool usb_if_enabled = lv_obj_has_state(ui_sw_sett_usb_if_toggle, LV_STATE_CHECKED);
    usb_if_enabled ? lv_obj_clear_state(ui_sw_sett_usb_direct_mon, LV_STATE_DISABLED) :
                     lv_obj_add_state(ui_sw_sett_usb_direct_mon, LV_STATE_DISABLED);

    const events::usb_audio_if_changed evt {usb_if_enabled};
    view->notify(evt);
}

void ui_settings_usb_direct_mon(lv_event_t * e)
{
    const events::usb_direct_mon_changed evt {lv_obj_has_state(ui_sw_sett_usb_direct_mon, LV_STATE_CHECKED)};
    view->notify(evt);
}

void ui_settings_add_effect(uint32_t id)
{
    const events::add_effect_request evt {static_cast<mfx::effect_id>(id)};
    view->notify(evt);
}

void ui_settings_remove_effect(uint32_t effect_id)
{
    const events::remove_effect_request evt {static_cast<mfx::effect_id>(effect_id)};
    view->notify(evt);
}

void ui_settings_move_effect(uint32_t effect_id, int32_t step)
{
    const events::move_effect_request evt {static_cast<mfx::effect_id>(effect_id), step};
    view->notify(evt);
}

void ui_settings_factory_reset(void)
{
    view->notify(events::factory_reset {});
}

void ui_settings_load_preset(const char * name)
{
    view->notify(events::load_preset {name});
}

void ui_settings_save_preset(const char * name)
{
    view->notify(events::save_preset {name});
}

void ui_settings_rename_preset(const char * old_name, const char * new_name)
{
    view->notify(events::rename_preset {old_name, new_name});
}

void ui_settings_remove_preset(const char * name)
{
    view->notify(events::remove_preset {name});
}

void ui_tuner_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::tuner);
}

void ui_tuner_mute(lv_event_t * e)
{
    notify_tuner_controls_changed();
}

void ui_tremolo_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::tremolo);
}

void ui_tremolo_rate_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_tremolo_depth_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_tremolo_shape_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_echo_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::echo);
}

void ui_echo_blur_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_feedb_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_time_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_mode_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_chorus_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::chorus);
}

void ui_chorus_mix_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_rate_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_depth_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_mode_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_reverb_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::reverb);
}

void ui_reverb_bw_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_reverb_damp_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_reverb_decay_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_reverb_mode_changed(lv_event_t * e)
{
    notify_reverb_controls_changed();
}

void ui_overdrive_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::overdrive);
}

void ui_overdrive_mix_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_low_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_gain_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_high_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_mode_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_cab_sim_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::cabinet_sim);
}

void ui_cab_sim_ir_changed(lv_event_t * e)
{
    notify_cabinet_sim_controls_changed();
}

void ui_vocoder_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::vocoder);
}

void ui_vocoder_clarity_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_tone_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_bands_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_mode_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_vocoder_hold_changed(lv_event_t * e)
{
    notify_vocoder_controls_changed();
}

void ui_phaser_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::phaser);
}

void ui_phaser_rate_changed(lv_event_t * e)
{
    notify_phaser_controls_changed();
}

void ui_phaser_depth_changed(lv_event_t * e)
{
    notify_phaser_controls_changed();
}

void ui_phaser_contour_changed(lv_event_t * e)
{
    notify_phaser_controls_changed();
}

void ui_amp_sim_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::amplifier_sim);
}

void ui_amp_sim_input_changed(lv_event_t * e)
{
    notify_amp_sim_controls_changed();
}

void ui_amp_sim_drive_changed(lv_event_t * e)
{
    notify_amp_sim_controls_changed();
}

void ui_amp_sim_compression_changed(lv_event_t * e)
{
    notify_amp_sim_controls_changed();
}

void ui_amp_sim_bass_changed(lv_event_t * e)
{
    notify_amp_sim_controls_changed();
}

void ui_amp_sim_mids_changed(lv_event_t * e)
{
    notify_amp_sim_controls_changed();
}

void ui_amp_sim_treb_changed(lv_event_t * e)
{
    notify_amp_sim_controls_changed();
}

void ui_amp_sim_mode_changed(lv_event_t * e)
{
    notify_amp_sim_controls_changed();
}



