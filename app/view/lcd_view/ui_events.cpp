// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.3.1
// LVGL version: 8.3.6
// Project name: gmfx

#include "ui.h"

#include "lcd_view.hpp"

#include <cassert>

//-----------------------------------------------------------------------------
/* private */

namespace
{

namespace events = mfx::lcd_view_events;

mfx::lcd_view *view;

void notify_effect_bypass_changed(lv_obj_t *obj, mfx::effect_id effect)
{
    bool bypassed = !lv_obj_has_state(obj, LV_STATE_CHECKED);
    const events::effect_bypass_changed evt {effect, bypassed};
    view->notify(evt);
}

void notify_tremolo_controls_changed(void)
{
    lv_obj_t *rate_knob = ui_arc_trem_rate;
    lv_obj_t *depth_knob = ui_arc_trem_depth;
    lv_obj_t *shape_sw = ui_sw_trem_shape;

    const mfx::tremolo_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(rate_knob)),
        static_cast<float>(lv_arc_get_value(depth_knob)) * 0.01f,
        lv_obj_has_state(shape_sw, LV_STATE_CHECKED) ?
        mfx::tremolo_attr::controls::shape_type::sine :
        mfx::tremolo_attr::controls::shape_type::triangle
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_echo_controls_changed(void)
{
    lv_obj_t *blur_knob = ui_arc_echo_blur;
    lv_obj_t *time_knob = ui_arc_echo_time;
    lv_obj_t *feedback_knob = ui_arc_echo_feedb;
    lv_obj_t *mode_sw = ui_sw_echo_mode;

    const mfx::echo_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(blur_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(time_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(feedback_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::echo_attr::controls::mode_type::delay :
        mfx::echo_attr::controls::mode_type::echo
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_chorus_controls_changed(void)
{
    lv_obj_t *mix_knob = ui_arc_chorus_mix;
    lv_obj_t *depth_knob = ui_arc_chorus_depth;
    lv_obj_t *rate_knob = ui_arc_chorus_rate;
    lv_obj_t *mode_sw = ui_sw_chorus_mode;

    const mfx::chorus_attr::controls ctrl
    {
        static_cast<float>(lv_arc_get_value(depth_knob)) * 0.001f,
        static_cast<float>(lv_arc_get_value(rate_knob)) * 0.01f,
        0.0f, // Not used
        static_cast<float>(lv_arc_get_value(mix_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::chorus_attr::controls::mode_type::mode_2 :
        mfx::chorus_attr::controls::mode_type::mode_1
    };

    view->notify(events::effect_controls_changed {ctrl});
}


void notify_overdrive_controls_changed(void)
{
    lv_obj_t *mix_knob = ui_arc_od_mix;
    lv_obj_t *gain_knob = ui_arc_od_gain;
    lv_obj_t *tone_knob = ui_arc_od_tone;
    lv_obj_t *mode_sw = ui_sw_od_mode;

    const mfx::overdrive_attr::controls ctrl
    {
        1.0f - (static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f),
        static_cast<float>(lv_arc_get_value(gain_knob)),
        static_cast<float>(lv_arc_get_value(tone_knob)) * 0.01f,
        static_cast<float>(lv_arc_get_value(mix_knob)) * 0.01f,
        lv_obj_has_state(mode_sw, LV_STATE_CHECKED) ?
        mfx::overdrive_attr::controls::mode_type::hard :
        mfx::overdrive_attr::controls::mode_type::soft
    };

    view->notify(events::effect_controls_changed {ctrl});
}

void notify_cabinet_sim_controls_changed(void)
{
    lv_obj_t *ir_list = ui_roller_cab_sim_ir;

    const mfx::cabinet_sim_attr::controls ctrl
    {
        mfx::cabinet_sim_attr::controls::resolution::standart,
        static_cast<uint8_t>(lv_roller_get_selected(ir_list)),
    };

    view->notify(events::effect_controls_changed {ctrl});
}

}

//-----------------------------------------------------------------------------
/* public */

void ui_set_user_data(void *user_data)
{
    assert(user_data != nullptr);
    view = static_cast<mfx::lcd_view*>(user_data);
}

void ui_user_init_actions(void)
{
    ui_fx_names_size = mfx::effect_name.size();
    ui_fx_names = mfx::effect_name.data();
}

void ui_splash_loaded(lv_event_t * e)
{
    view->notify(events::splash_loaded {});
}

void ui_effect_next(lv_event_t * e)
{
    view->notify(events::next_effect_screen_request {});
}

void ui_effect_prev(lv_event_t * e)
{
    view->notify(events::prev_effect_screen_request {});
}

void ui_settings_in_vol_changed(lv_event_t * e)
{
    lv_obj_t *in_slider = ui_sld_sett_in_vol;
    lv_obj_t *out_slider = ui_sld_sett_out_vol;

    uint8_t in_vol = lv_slider_get_value(in_slider);
    uint8_t out_vol = lv_slider_get_value(out_slider);

    const events::volume_changed evt {in_vol, out_vol};
    view->notify(evt);
}

void ui_settings_out_vol_changed(lv_event_t * e)
{
    lv_obj_t *in_slider = ui_sld_sett_in_vol;
    lv_obj_t *out_slider = ui_sld_sett_out_vol;

    uint8_t in_vol = lv_slider_get_value(in_slider);
    uint8_t out_vol = lv_slider_get_value(out_slider);

    const events::volume_changed evt {in_vol, out_vol};
    view->notify(evt);
}

void ui_settings_mute_audio(lv_event_t * e)
{
    const events::mute_changed evt {lv_obj_has_state(ui_sw_sett_mute_audio, LV_STATE_CHECKED)};
    view->notify(evt);
}

void ui_settings_add_effect(uint32_t id, uint32_t curr_id)
{
    const events::add_effect_request evt {static_cast<mfx::effect_id>(id), static_cast<mfx::effect_id>(curr_id)};
    view->notify(evt);
}

void ui_settings_remove_effect(uint32_t effect_id)
{
    const events::remove_effect_request evt {static_cast<mfx::effect_id>(effect_id)};
    view->notify(evt);
}

void ui_settings_move_effect(uint32_t effect_id, int32_t step)
{
    const events::move_effect_request evt {static_cast<mfx::effect_id>(effect_id), step};
    view->notify(evt);
}

void ui_tremolo_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::tremolo);
}

void ui_tremolo_rate_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_tremolo_depth_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_tremolo_shape_changed(lv_event_t * e)
{
    notify_tremolo_controls_changed();
}

void ui_echo_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::echo);
}

void ui_echo_blur_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_feedb_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_time_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_echo_mode_changed(lv_event_t * e)
{
    notify_echo_controls_changed();
}

void ui_chorus_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::chorus);
}

void ui_chorus_mix_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_rate_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_depth_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_chorus_mode_changed(lv_event_t * e)
{
    notify_chorus_controls_changed();
}

void ui_overdrive_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::overdrive);
}

void ui_overdrive_low_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_gain_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_high_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_overdrive_mode_changed(lv_event_t * e)
{
    notify_overdrive_controls_changed();
}

void ui_cab_sim_bypass(lv_event_t * e)
{
    notify_effect_bypass_changed(lv_event_get_target(e), mfx::effect_id::cabinet_sim);
}

void ui_cab_sim_ir(lv_event_t * e)
{
    notify_cabinet_sim_controls_changed();
}


